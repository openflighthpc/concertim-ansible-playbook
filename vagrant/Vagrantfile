CODE_PATH = [ ENV['FLIGHT_CODE'], "#{ENV['HOME']}/code" ]
  .compact
  .map { |p| File.expand_path(p) }
  .detect { |p| File.directory?(p) }
CT_SOURCES = File.join(CODE_PATH, 'concertim-sources')
ANSIBLE_DIR="../ansible"
MACHINES = [
  {
    name: "command1",
    box: "ubuntu/jammy64",
  },
  {
    name: "command2",
    # box: "bento/ubuntu-22.04",
    box: "ubuntu/jammy64",
  },
  {
    name: "command3",
    # box: "ubuntu/focal64",
    box: "ubuntu/jammy64",
  }
]
PLAYBOOKS = [
  {
    id: "package",
    path: File.join(ANSIBLE_DIR, "package-assets-playbook.yml"),
    extra_vars: {
      'gh_token' => ENV.fetch('GH_TOKEN', ''),
      'aws_access_key_id' => ENV.fetch('AWS_ACCESS_KEY_ID', ''),
      'aws_secret_access_key' => ENV.fetch('AWS_SECRET_ACCESS_KEY', ''),
      'release_tag' => ENV.fetch('MIA_RELEASE_TAG', ''),
    }
  },
  {
    id: "prep",
    path: File.join(ANSIBLE_DIR, "prep-playbook.yml"),
    extra_vars: {}
  },
  {
    id: "build",
    path: File.join(ANSIBLE_DIR, "build-playbook.yml"),
    extra_vars: {
      'aws_access_key_id' => ENV.fetch('AWS_ACCESS_KEY_ID', ''),
      'aws_secret_access_key' => ENV.fetch('AWS_SECRET_ACCESS_KEY', ''),
      'release_tag' => ENV.fetch('MIA_RELEASE_TAG', ''),
    }
  },
  {
    id: "configure",
    path: File.join(ANSIBLE_DIR, "configure-playbook.yml"),
    extra_vars: {}
  },
]

KNOWN_ENV_VARS = %w(
  ANSIBLE_START_AT_TASK
  ANSIBLE_TAGS
  ANSIBLE_VERBOSE
)

class BadEnvVars < Vagrant::Errors::VagrantError
  def error_message
    env_vars = @extra_data[:env_vars]
    "Badly named environment variables #{env_vars}.  " \
      "Valid values are #{KNOWN_ENV_VARS.join(', ')}"
  end
end

Vagrant.configure("2") do |config|
  assert_good_env_vars

  MACHINES.each_with_index do |box, idx|
    config.vm.provider "virtualbox" do |v|
      # v.memory = 8192
      v.memory = 4096
      # v.memory = 3072
      # v.memory = 2048
    end

    config.vm.define box[:name], primary: idx == 0 do |v|
      v.vm.box = box[:box]
      v.vm.hostname = box[:name]
      v.vm.network "forwarded_port", guest:  80, host: 9080 + idx + 1, host_ip: '127.0.0.1'
      v.vm.network "forwarded_port", guest: 443, host: 9443 + idx + 1, host_ip: '127.0.0.1'
      v.vm.provision "swap",
        type: "shell",
        path: "scripts/create-swap.sh",
        run: "never"
      v.vm.provision "apt-upgrade",
        type: "shell",
        inline: "apt-get -y update && apt-get -y upgrade",
        run: "never"

      unless to_boolean(ENV['ACCEPTANCE'])
        v.vm.synced_folder ANSIBLE_DIR, "/ansible"
        # if File.directory?(CODE_PATH)
        #   v.vm.synced_folder CODE_PATH, "/code"
        # end
        if File.directory?(CT_SOURCES)
          v.vm.synced_folder CT_SOURCES, "/data/private/share/dev"
        end

        playbooks.each do |playbook|
          v.vm.provision "#{playbook[:id]}_playbook", type: "ansible_local", run: "never" do |ansible|
            ansible.playbook = playbook[:path]
            ansible.verbose = to_boolean(ENV.fetch('ANSIBLE_VERBOSE', 'false'))
            ansible.extra_vars = playbook[:extra_vars]

            if ENV.key?('ANSIBLE_START_AT_TASK')
              ansible.start_at_task = ENV['ANSIBLE_START_AT_TASK']
            end
            if ENV.key?('ANSIBLE_TAGS')
              ansible.tags = ENV['ANSIBLE_TAGS']
            end
          end
        end
      end
    end
  end
end

def playbooks
  PLAYBOOKS
end

def to_boolean(v)
  case v
  when /true/i, /yes/i, "1"
    true
  else
    false
  end
end

def assert_good_env_vars
  bad_vars = ENV.keys.grep(/^ansible/i) - KNOWN_ENV_VARS
  unless bad_vars.empty?
    raise BadEnvVars, {env_vars: bad_vars.join(', ')}
  end
end
